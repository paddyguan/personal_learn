## 排序算法 

* 排序

  * 外部排序

    内存与外存结合的排序，外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

  * 内部排序

    只使用内存

    * 插入排序
      * 直接插入排序 
      * 希尔排序
    * 选择排序
      * 简单堆排序
      * 堆排序
    * 交换排序
      * 冒泡排序
      * 快速排序
    * 归并排序
    * 基数排序



### 直接插入排序(Straight Insertion Sorted)

将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。时间复杂度是(n^2)。直接插入排序的衍生方式有二分插入排序，2-路插入排序

![](http://imgsrc.baidu.com/baike/pic/item/e7cd7b899e510fb30f0a9f93d033c895d1430ca6.jpg) 

### 希尔排序（缩小增量排序, Shell Sorted）

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

![](http://imgsrc.baidu.com/baike/pic/item/79f0f736afc37931650034dfe8c4b74542a911df.jpg)  

过程：

1. 选择一增量序列t1,t2,...,tk，其中ti>tj
2. 按增量序列个数k，对序列进行k趟排序
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度



### 简单选择排序(Simple Selection Sort)

在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。



### 堆排序(Heap Sort)

利用小根堆和大根堆的特性（小根堆的根最小，大根堆的根最大）。初始时把要排序的n个数的序列看作是一棵**顺序存储的二叉树（一维数组存储二叉树）**，调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为**堆排序**。

从1亿个数中找出最大的10个数可以利用相似的远离，只需要遍历一次数组即可得出结果。

### 冒泡算法(Bubble Sort)

在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

### 快速排序(Quick Sort)

1. 选择一个基准元素,通常选择第一个元素或者最后一个元素,
2. 通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。
3. 此时基准元素在其排好序后的正确位置
4. 然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序

```java
public static void quickSortedRecursion(int[] nums, int startPos, int endPos){
        if(startPos>=endPos)
            return;
        int i = startPos, j = endPos;
        int index = nums[i];
        while (i<j){
             while (i<j && nums[j] > index){
                j--;
            }
            swap(nums, i, j);
            while (i<j && index > nums[i]){
                i++;
            }
            swap(nums, i, j);
        }
        quickSortedRecursion(nums, startPos, i-1);
        quickSortedRecursion(nums, i+1, endPos);
    }

//调用：quickSotredRecusion(nums, 0, nums.length-1);
```





